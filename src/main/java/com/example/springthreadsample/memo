・スレッド
タスクの完了:
スレッドは与えられたタスク（例えば、データの計算、ファイルの読み書きなど）を終えます。
タスクが終わると、スレッドはそれ以上の作業がないことをシステムに通知します。
リソースの解放:
スレッドが使用していたメモリや他のリソース（開いていたファイルなど）は、タスクが終了すると解放されます。
これにより、そのリソースを他のプロセスやスレッドが使えるようになります。
スレッドの終了:
スレッドは自動的に「終了」状態になります。プログラムによっては、スレッドが終了したことを他の部分に通知することもあります。
これは他のスレッドがその終了を待っている場合に重要です。
クリーンアップ操作:
システムやプログラムは、スレッドが終了した後に必要なクリーンアップ操作を行います。
これには、使用していたメモリの完全な解放や、スレッドが開いていたファイルのクローズなどが含まれます。


・スレッドプール
スレッドプールは、タスク（プログラムの一部の作業）を受け取り、
空いているスレッドにそのタスクを割り当てます。
タスクが終わったら、そのスレッドはプールに戻り、次のタスクを待ちます。
このようにして、スレッドプールは常に活動的にタスクを処理し続けます。

食事を提供するための限られた数の窓口があるとします。
生徒が列を作って順番に食事を取りに行くのを想像してください。
ここで、窓口は「スレッド」、生徒の列は「タスク」、
そしてカフェテリア全体が「スレッドプール」となります。窓口が空いていれば、次の生徒が前に進んで食事を受け取ります。
窓口の数は限られているため、すべてが効率的に運営され、カオスを防ぐことができます。


・shutdown()
新しいタスクを受け入れないようにする
たまっているタスクがあれば終わるまで処理が終わるまでをまつ

・awaitTermination()
溜まっているタスクが終わる時間を設定するのと、終わったら閉めるようにする
高校の放課後の部活動を考えてみましょう。
部活の顧問教師は、活動の終了時刻になったら部活の新しい活動を開始させないようにします（これが shutdown()）。
生徒がすべての準備を整えて帰るのを待ち、最後の一人が部室を出るまで教師は部室にいます（これが awaitTermination()）。
部室が空になったことを確認してから、教師は部室のドアを施錠して帰宅します。
これにより、部室内の物品が安全に保たれ、何も忘れられていないことが確認されます。

・Safe、Unsafeについて
synchronizedは同時に複数のスレッドから呼び出されても一度に一つのスレッドがメソッドを実行できる
ない場合は、両スレッドがカウントの同じ初期値（例えば0）を読み取り、両方ともそれに1を加えた値（1）をメモリに書き戻すかもしれません。
その結果、カウントが2回インクリメントされるべきところが1回しかされないという問題が発生します

